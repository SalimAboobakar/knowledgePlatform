import {
  collection,
  doc,
  getDocs,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  setDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
  writeBatch,
  onSnapshot,
} from "firebase/firestore";
import {
  ref,
  uploadBytes,
  getDownloadURL,
  deleteObject,
} from "firebase/storage";
import { db, storage } from "../config/firebase";
import { Project, User, TodoItem } from "../data/mockData";

// Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
export interface FirebaseProject extends Omit<Project, "id"> {
  id?: string;
  createdAt: any;
  updatedAt: any;
}

export interface FirebaseUser extends Omit<User, "id"> {
  id?: string;
  createdAt: any;
  updatedAt: any;
}

export interface FirebaseTodoItem extends Omit<TodoItem, "id"> {
  id?: string;
  createdAt: any;
  completedAt?: any;
}

// Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
export interface Message {
  id?: string;
  senderId: string;
  content: string;
  timestamp: any;
  type: "text" | "file" | "image";
  fileUrl?: string;
  fileName?: string;
  isRead: boolean;
}

export interface Conversation {
  id?: string;
  participants: string[]; // array of user IDs
  lastMessage?: Message;
  unreadCount?: number;
  isGroup: boolean;
  groupName?: string;
  groupAvatar?: string;
  createdAt: any;
  updatedAt: any;
}

// Ø®Ø¯Ù…Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
export class ProjectService {
  private static collectionName = "projects";

  // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
  static async getAllProjects(): Promise<Project[]> {
    try {
      const querySnapshot = await getDocs(collection(db, this.collectionName));
      return querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Project[];
    } catch (error: any) {
      console.error("Error fetching projects:", error);
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ù…Ø´Ø§Ø±ÙŠØ¹ Ø­Ø³Ø¨ Ø¯ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  static async getProjectsByUserRole(user: User): Promise<Project[]> {
    try {
      // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø­Ø³Ø¨ Ø¯ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…

      // Validate user object
      if (!user || !user.id || !user.role) {
        console.warn("âš ï¸ Invalid user object:", user);
        return [];
      }

      let q;

      switch (user.role) {
        case "student":
          console.log("ğŸ‘¨â€ğŸ“ Fetching projects for student with ID:", user.id);
          q = query(
            collection(db, this.collectionName),
            where("studentId", "==", user.id)
          );
          break;
        case "supervisor":
          // Ø§Ù„Ù…Ø´Ø±Ù - Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„ØªÙŠ ÙŠØ´Ø±Ù Ø¹Ù„ÙŠÙ‡Ø§
          q = query(
            collection(db, this.collectionName),
            where("supervisorId", "==", user.id)
          );
          break;
        case "admin":
          console.log("ğŸ‘¨â€ğŸ’¼ Fetching all projects for admin");
          q = query(collection(db, this.collectionName));
          break;
        default:
          console.warn("âš ï¸ Unknown user role:", user.role);
          return [];
      }

      const querySnapshot = await getDocs(q);
      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹

      const projects = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Project[];

      // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… orderBy ÙÙŠ Firestore
      return projects.sort((a, b) => {
        const dateA = new Date(a.updatedAt || 0);
        const dateB = new Date(b.updatedAt || 0);
        return dateB.getTime() - dateA.getTime();
      });
    } catch (error: any) {
      console.error("Error fetching projects by user role:", error);
      console.error("Error details:", {
        user: user,
        error: error.message,
        code: error.code,
      });
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ù…Ø´Ø±ÙˆØ¹ ÙˆØ§Ø­Ø¯
  static async getProjectById(projectId: string): Promise<Project | null> {
    try {
      const docRef = doc(db, this.collectionName, projectId);
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        return {
          id: docSnap.id,
          ...docSnap.data(),
        } as Project;
      }
      return null;
    } catch (error: any) {
      console.error("Error fetching project:", error);
      throw error;
    }
  }

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯
  static async createProject(
    projectData: Omit<Project, "id" | "createdAt" | "updatedAt">
  ): Promise<string> {
    try {
      const projectRef = await addDoc(collection(db, this.collectionName), {
        ...projectData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
      return projectRef.id;
    } catch (error: any) {
      console.error("Error creating project:", error);
      throw error;
    }
  }

  // ØªØ­Ø¯ÙŠØ« Ù…Ø´Ø±ÙˆØ¹
  static async updateProject(
    projectId: string,
    projectData: Partial<Project>
  ): Promise<void> {
    try {
      const projectRef = doc(db, this.collectionName, projectId);
      await updateDoc(projectRef, {
        ...projectData,
        updatedAt: serverTimestamp(),
      });
    } catch (error: any) {
      console.error("Error updating project:", error);
      throw error;
    }
  }

  // Ø­Ø°Ù Ù…Ø´Ø±ÙˆØ¹
  static async deleteProject(projectId: string): Promise<void> {
    try {
      const projectRef = doc(db, this.collectionName, projectId);
      await deleteDoc(projectRef);
    } catch (error: any) {
      console.error("Error deleting project:", error);
      throw error;
    }
  }

  // Ø¥Ø¶Ø§ÙØ© Ø·Ø§Ù„Ø¨ Ø¥Ù„Ù‰ Ù…Ø´Ø±ÙˆØ¹
  static async addStudentToProject(
    projectId: string,
    studentId: string
  ): Promise<void> {
    try {
      const project = await this.getProjectById(projectId);
      if (!project) {
        throw new Error("Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯");
      }

      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      const students = project.students || [];
      if (!students.includes(studentId)) {
        students.push(studentId);
        await this.updateProject(projectId, { students });
      }
    } catch (error: any) {
      console.error("Error adding student to project:", error);
      throw error;
    }
  }

  // Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ù„Ù‰ Ù…Ø´Ø±ÙˆØ¹
  static async addTask(projectId: string, task: any): Promise<void> {
    try {
      const project = await this.getProjectById(projectId);
      if (!project) {
        throw new Error("Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯");
      }

      const todoList = project.todoList || [];
      todoList.push(task);

      await this.updateProject(projectId, {
        todoList,
        updatedAt: new Date().toISOString(),
      });
    } catch (error: any) {
      console.error("Error adding task:", error);
      throw error;
    }
  }

  // ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
  static async updateTask(projectId: string, updatedTask: any): Promise<void> {
    try {
      const project = await this.getProjectById(projectId);
      if (!project) {
        throw new Error("Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯");
      }

      const todoList = project.todoList || [];
      const taskIndex = todoList.findIndex(
        (task) => task.id === updatedTask.id
      );

      if (taskIndex !== -1) {
        todoList[taskIndex] = updatedTask;
        await this.updateProject(projectId, {
          todoList,
          updatedAt: new Date().toISOString(),
        });
      } else {
        throw new Error("Ø§Ù„Ù…Ù‡Ù…Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
      }
    } catch (error: any) {
      console.error("Error updating task:", error);
      throw error;
    }
  }

  // Ø­Ø°Ù Ù…Ù‡Ù…Ø© Ù…Ù† Ù…Ø´Ø±ÙˆØ¹
  static async deleteTask(projectId: string, taskId: string): Promise<void> {
    try {
      const project = await this.getProjectById(projectId);
      if (!project) {
        throw new Error("Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯");
      }

      const todoList =
        project.todoList?.filter((task) => task.id !== taskId) || [];
      await this.updateProject(projectId, {
        todoList,
        updatedAt: new Date().toISOString(),
      });
    } catch (error: any) {
      console.error("Error deleting task:", error);
      throw error;
    }
  }

  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ù…Ù‡Ù…Ø©
  static async updateTodoStatus(
    projectId: string,
    todoId: string,
    completed: boolean
  ): Promise<void> {
    try {
      const projectRef = doc(db, this.collectionName, projectId);
      const projectSnap = await getDoc(projectRef);

      if (projectSnap.exists()) {
        const project = projectSnap.data() as Project;
        const updatedTodoList = project.todoList.map((todo) => {
          if (todo.id === todoId) {
            return {
              ...todo,
              completed,
              completedAt: completed ? new Date().toISOString() : undefined,
            };
          }
          return todo;
        });

        // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
        const progress = this.calculateProgress(updatedTodoList);

        await updateDoc(projectRef, {
          todoList: updatedTodoList,
          progress,
          updatedAt: serverTimestamp(),
        });
      }
    } catch (error: any) {
      console.error("Error updating todo status:", error);
      throw error;
    }
  }

  // Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©
  static async addTodoItem(
    projectId: string,
    todoData: Omit<TodoItem, "id" | "createdAt">
  ): Promise<void> {
    try {
      const projectRef = doc(db, this.collectionName, projectId);
      const projectSnap = await getDoc(projectRef);

      if (projectSnap.exists()) {
        const project = projectSnap.data() as Project;
        const newTodo: TodoItem = {
          ...todoData,
          id: `todo-${Date.now()}`,
          createdAt: new Date().toISOString(),
        };

        const updatedTodoList = [...project.todoList, newTodo];
        const progress = this.calculateProgress(updatedTodoList);

        await updateDoc(projectRef, {
          todoList: updatedTodoList,
          progress,
          updatedAt: serverTimestamp(),
        });
      }
    } catch (error: any) {
      console.error("Error adding todo item:", error);
      throw error;
    }
  }

  // Ø­Ø°Ù Ù…Ù‡Ù…Ø©
  static async deleteTodoItem(
    projectId: string,
    todoId: string
  ): Promise<void> {
    try {
      const projectRef = doc(db, this.collectionName, projectId);
      const projectSnap = await getDoc(projectRef);

      if (projectSnap.exists()) {
        const project = projectSnap.data() as Project;
        const updatedTodoList = project.todoList.filter(
          (todo) => todo.id !== todoId
        );
        const progress = this.calculateProgress(updatedTodoList);

        await updateDoc(projectRef, {
          todoList: updatedTodoList,
          progress,
          updatedAt: serverTimestamp(),
        });
      }
    } catch (error: any) {
      console.error("Error deleting todo item:", error);
      throw error;
    }
  }

  // Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„ØªÙ‚Ø¯Ù…
  private static calculateProgress(todoList: TodoItem[]): number {
    if (todoList.length === 0) return 0;
    const completedTasks = todoList.filter((todo) => todo.completed).length;
    return Math.round((completedTasks / todoList.length) * 100);
  }

  // Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
  static subscribeToProjects(
    user: User,
    callback: (projects: Project[]) => void
  ) {
    try {
      console.log("ğŸ” Setting up project subscription for user:", {
        id: user.id,
        role: user.role,
        email: user.email,
      });

      // Validate user object
      if (!user || !user.id || !user.role) {
        console.warn("âš ï¸ Invalid user object for subscription:", user);
        callback([]);
        return () => {};
      }

      let q;

      switch (user.role) {
        case "student":
          console.log(
            "ğŸ‘¨â€ğŸ“ Subscribing to projects for student with ID:",
            user.id
          );
          q = query(
            collection(db, this.collectionName),
            where("studentId", "==", user.id)
          );
          break;
        case "supervisor":
          console.log(
            "ğŸ‘¨â€ğŸ« Subscribing to projects for supervisor with ID:",
            user.id
          );
          q = query(
            collection(db, this.collectionName),
            where("supervisorId", "==", user.id)
          );
          break;
        case "admin":
          console.log("ğŸ‘¨â€ğŸ’¼ Subscribing to all projects for admin");
          q = query(collection(db, this.collectionName));
          break;
        default:
          console.warn("âš ï¸ Unknown user role for subscription:", user.role);
          callback([]);
          return () => {};
      }

      return onSnapshot(
        q,
        (querySnapshot) => {
          console.log(
            `ğŸ“‹ Project subscription update: ${querySnapshot.docs.length} projects`
          );
          const projects = querySnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          })) as Project[];

          // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹
          const sortedProjects = projects.sort((a, b) => {
            const dateA = new Date(a.updatedAt || 0);
            const dateB = new Date(b.updatedAt || 0);
            return dateB.getTime() - dateA.getTime();
          });

          callback(sortedProjects);
        },
        (error) => {
          console.error("âŒ Project subscription error:", error);
          console.error("âŒ Error details:", {
            user: user,
            error: error.message,
            code: error.code,
            stack: error.stack,
          });
          // Return empty array on error
          callback([]);
        }
      );
    } catch (error) {
      console.error("âŒ Error setting up project subscription:", error);
      callback([]);
      return () => {};
    }
  }
}

// Ø®Ø¯Ù…Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
export class UserService {
  private static collectionName = "users";

  // Utility function to ensure user document exists
  static async ensureUserDocument(firebaseUser: any): Promise<User | null> {
    try {
      console.log(
        "ğŸ” Ensuring user document for:",
        firebaseUser.email,
        "UID:",
        firebaseUser.uid
      );

      // First try to get the user by Firebase UID (this should be the document ID)
      let user = await this.getUserById(firebaseUser.uid);

      if (!user) {
        // If not found by UID, try by email
        user = await this.getUserByEmail(firebaseUser.email || "");
      }

      if (!user) {
        // If user doesn't exist, create a basic user document
        console.log("ğŸ“ Creating user document for:", firebaseUser.email);
        const userData: Omit<User, "id" | "createdAt" | "updatedAt"> = {
          name: firebaseUser.displayName || "Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯",
          email: firebaseUser.email || "",
          role: "student" as const,
          department: "ØºÙŠØ± Ù…Ø­Ø¯Ø¯",
          specialization: "ØºÙŠØ± Ù…Ø­Ø¯Ø¯",
          avatar: firebaseUser.displayName?.charAt(0) || "Ù…",
          phone: "",
          studentId: "",
        };

        // Create the document with the Firebase UID as the document ID
        const userRef = doc(db, this.collectionName, firebaseUser.uid);
        await setDoc(userRef, {
          ...userData,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        });

        console.log("âœ… User document created with UID:", firebaseUser.uid);
        user = await this.getUserById(firebaseUser.uid);
      } else {
        console.log("âœ… User document found:", user.id);
      }

      return user;
    } catch (error) {
      console.error("âŒ Error ensuring user document:", error);
      return null;
    }
  }

  // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ù…Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„
  static async createUserWithCustomData(
    firebaseUser: any,
    customUserData: Omit<User, "id" | "createdAt" | "updatedAt">
  ): Promise<User | null> {
    try {
      console.log(
        "ğŸ” Creating user with custom data for:",
        firebaseUser.email,
        "UID:",
        firebaseUser.uid
      );

      console.log("ğŸ“ Custom user data:", customUserData);

      // Create the document with the Firebase UID as the document ID
      const userRef = doc(db, this.collectionName, firebaseUser.uid);

      const finalUserData = {
        ...customUserData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };

      console.log("ğŸ“„ Final user data to write:", finalUserData);

      await setDoc(userRef, finalUserData);

      console.log(
        "âœ… User document created with custom data, UID:",
        firebaseUser.uid
      );
      const user = await this.getUserById(firebaseUser.uid);
      return user;
    } catch (error: any) {
      console.error("âŒ Error creating user with custom data:", error);
      console.error("âŒ Error details:", {
        firebaseUser: {
          uid: firebaseUser.uid,
          email: firebaseUser.email,
        },
        customUserData,
        error: error.message,
        code: error.code,
      });
      return null;
    }
  }

  // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  static async getAllUsers(): Promise<User[]> {
    try {
      const querySnapshot = await getDocs(collection(db, this.collectionName));
      return querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as User[];
    } catch (error: any) {
      console.error("Error fetching users:", error);
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ù…Ø³ØªØ®Ø¯Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø¹Ø±Ù
  static async getUserById(userId: string): Promise<User | null> {
    try {
      const docRef = doc(db, this.collectionName, userId);
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        return {
          id: docSnap.id,
          ...docSnap.data(),
        } as User;
      }
      return null;
    } catch (error: any) {
      console.error("Error fetching user by ID:", error);
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ù…Ø³ØªØ®Ø¯Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
  static async getUserByEmail(email: string): Promise<User | null> {
    try {
      if (!email) {
        console.warn("getUserByEmail called with empty email");
        return null;
      }

      const q = query(
        collection(db, this.collectionName),
        where("email", "==", email)
      );
      const querySnapshot = await getDocs(q);

      if (!querySnapshot.empty) {
        const doc = querySnapshot.docs[0];
        return {
          id: doc.id,
          ...doc.data(),
        } as User;
      }
      return null;
    } catch (error: any) {
      console.error("Error fetching user by email:", error);
      // Don't throw the error, just return null to avoid breaking the auth flow
      return null;
    }
  }

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
  static async createUser(
    userData: Omit<User, "id" | "createdAt" | "updatedAt">
  ): Promise<string> {
    try {
      const userRef = await addDoc(collection(db, this.collectionName), {
        ...userData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      });
      return userRef.id;
    } catch (error: any) {
      console.error("Error creating user:", error);
      throw error;
    }
  }

  // ØªØ­Ø¯ÙŠØ« Ù…Ø³ØªØ®Ø¯Ù…
  static async updateUser(
    userId: string,
    userData: Partial<User>
  ): Promise<void> {
    try {
      const userRef = doc(db, this.collectionName, userId);
      await updateDoc(userRef, {
        ...userData,
        updatedAt: serverTimestamp(),
      });
    } catch (error: any) {
      console.error("Error updating user:", error);
      throw error;
    }
  }

  // Ø­Ø°Ù Ù…Ø³ØªØ®Ø¯Ù…
  static async deleteUser(userId: string): Promise<void> {
    try {
      const userRef = doc(db, this.collectionName, userId);
      await deleteDoc(userRef);
    } catch (error: any) {
      console.error("Error deleting user:", error);
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø­Ø³Ø¨ Ø§Ù„Ø¯ÙˆØ±
  static async getUsersByRole(
    role: "student" | "supervisor" | "admin"
  ): Promise<User[]> {
    try {
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† orderBy
      const q = query(
        collection(db, this.collectionName),
        where("role", "==", role)
      );
      const querySnapshot = await getDocs(q);
      const users = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as User[];

      // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø± Ø­Ø³Ø¨ ID ÙˆØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹
      const uniqueUsers = users.filter(
        (user, index, self) => index === self.findIndex((u) => u.id === user.id)
      );
      return uniqueUsers.sort((a, b) =>
        (a.name || "").localeCompare(b.name || "")
      );
    } catch (error: any) {
      console.error("Error fetching users by role:", error);
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø­Ø³Ø¨ Ø§Ù„ØªØ®ØµØµ
  static async getStudentsBySpecialization(
    specialization: string
  ): Promise<User[]> {
    try {
      console.log(
        "ğŸ” Searching for students with specialization:",
        specialization
      );

      // Ø£ÙˆÙ„Ø§Ù‹ Ù†Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø«Ù… Ù†ÙÙ„ØªØ± Ù…Ø­Ù„ÙŠØ§Ù‹ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù…Ø´Ø§ÙƒÙ„ ÙÙŠ Firebase
      const q = query(
        collection(db, this.collectionName),
        where("role", "==", "student"),
        orderBy("name", "asc")
      );
      const querySnapshot = await getDocs(q);
      const allStudents = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as User[];

      console.log("ğŸ“Š All students from Firebase:", allStudents);
      console.log(
        "ğŸ“‹ Available specializations:",
        Array.from(new Set(allStudents.map((s) => s.specialization)))
      );

      // ÙÙ„ØªØ±Ø© Ù…Ø­Ù„ÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ØªØ®ØµØµ
      const filteredStudents = allStudents.filter((student) => {
        const matches = student.specialization === specialization;
        console.log(
          `ğŸ¯ Student: ${student.name}, Specialization: "${student.specialization}", Matches: ${matches}`
        );
        return matches;
      });

      console.log("âœ… Filtered students by specialization:", filteredStudents);
      console.log(
        `ğŸ“ˆ Found ${filteredStudents.length} students for specialization: "${specialization}"`
      );

      return filteredStudents;
    } catch (error) {
      console.error("âŒ Error fetching students by specialization:", error);
      return [];
    }
  }

  // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ø­Ø³Ø¨ Ø§Ù„ØªØ®ØµØµ
  static async getSupervisorsBySpecialization(
    specialization: string
  ): Promise<User[]> {
    try {
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† orderBy
      const q = query(
        collection(db, this.collectionName),
        where("role", "==", "supervisor"),
        where("specialization", "==", specialization)
      );
      const querySnapshot = await getDocs(q);
      const users = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as User[];

      // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø± Ø­Ø³Ø¨ ID ÙˆØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹
      const uniqueUsers = users.filter(
        (user, index, self) => index === self.findIndex((u) => u.id === user.id)
      );
      return uniqueUsers.sort((a, b) =>
        (a.name || "").localeCompare(b.name || "")
      );
    } catch (error: any) {
      console.error("Error fetching supervisors by specialization:", error);
      throw error;
    }
  }

  // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„ØªØ®ØµØµ
  static async searchUsers(
    searchTerm: string,
    role?: "student" | "supervisor" | "admin"
  ): Promise<User[]> {
    try {
      let q;

      if (role) {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† orderBy
        q = query(
          collection(db, this.collectionName),
          where("role", "==", role)
        );
      } else {
        q = query(collection(db, this.collectionName));
      }

      const querySnapshot = await getDocs(q);
      const users = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as User[];

      // ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ù…ØµØ·Ù„Ø­ Ø§Ù„Ø¨Ø­Ø«
      const searchLower = searchTerm.toLowerCase();
      const filteredUsers = users.filter(
        (user) =>
          (user.name || "").toLowerCase().includes(searchLower) ||
          (user.specialization || "").toLowerCase().includes(searchLower) ||
          (user.department || "").toLowerCase().includes(searchLower) ||
          (user.studentId || "").toLowerCase().includes(searchLower) ||
          (user.supervisorId || "").toLowerCase().includes(searchLower)
      );

      // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹
      return filteredUsers.sort((a, b) =>
        (a.name || "").localeCompare(b.name || "")
      );
    } catch (error: any) {
      console.error("Error searching users:", error);
      throw error;
    }
  }
}

// Ø®Ø¯Ù…Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
export class FileService {
  // Ø±ÙØ¹ Ù…Ù„Ù Ø¥Ù„Ù‰ Firebase Storage
  static async uploadFile(
    file: File,
    folder: string = "uploads"
  ): Promise<string> {
    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ø³Ù… ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ù„Ù
      const timestamp = Date.now();
      const randomString = Math.random().toString(36).substring(2, 15);
      const fileExtension = file.name.split(".").pop();
      const fileName = `${timestamp}_${randomString}.${fileExtension}`;

      // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø±Ø¬Ø¹ Ù„Ù„Ù…Ù„Ù ÙÙŠ Storage
      const storageRef = ref(storage, `${folder}/${fileName}`);

      // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù
      const snapshot = await uploadBytes(storageRef, file);

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ­Ù…ÙŠÙ„
      const downloadURL = await getDownloadURL(snapshot.ref);

      return downloadURL;
    } catch (error) {
      console.error("Error uploading file:", error);
      throw new Error("ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù");
    }
  }

  // Ø­Ø°Ù Ù…Ù„Ù Ù…Ù† Firebase Storage
  static async deleteFile(fileUrl: string): Promise<void> {
    try {
      const fileRef = ref(storage, fileUrl);
      await deleteObject(fileRef);
    } catch (error) {
      console.error("Error deleting file:", error);
      throw new Error("ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù");
    }
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø³Ù…ÙˆØ­
  static isAllowedFileType(file: File): boolean {
    const allowedTypes = [
      "application/pdf",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "image/jpeg",
      "image/png",
      "image/gif",
      "text/plain",
      "application/zip",
      "application/x-rar-compressed",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/vnd.ms-powerpoint",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ];

    return allowedTypes.includes(file.type);
  }

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
  static isFileSizeValid(file: File, maxSizeMB: number = 10): boolean {
    const maxSizeBytes = maxSizeMB * 1024 * 1024;
    return file.size <= maxSizeBytes;
  }
}

// Ø®Ø¯Ù…Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„
export class ChatService {
  private static conversationsCollection = "conversations";
  private static messagesCollection = "messages";

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø© Ø¬Ø¯ÙŠØ¯Ø©
  static async createConversation(
    participants: string[],
    isGroup: boolean = false,
    groupName?: string,
    groupAvatar?: string
  ): Promise<string> {
    try {
      console.log("ğŸ” Creating conversation with:", {
        participants,
        isGroup,
        groupName,
        groupAvatar,
      });

      const conversationData: any = {
        participants,
        isGroup,
        unreadCount: 0,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };

      // Ø¥Ø¶Ø§ÙØ© groupName ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ ÙˆÙ„ÙŠØ³ undefined
      if (isGroup && groupName && groupName.trim() !== "") {
        conversationData.groupName = groupName;
        console.log("âœ… Added groupName:", groupName);
      } else if (isGroup) {
        console.log("âš ï¸ Group chat but no valid groupName provided");
      }

      // Ø¥Ø¶Ø§ÙØ© groupAvatar ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ ÙˆÙ„ÙŠØ³ undefined
      if (isGroup && groupAvatar && groupAvatar.trim() !== "") {
        conversationData.groupAvatar = groupAvatar;
        console.log("âœ… Added groupAvatar:", groupAvatar);
      } else if (isGroup) {
        console.log("âš ï¸ Group chat but no valid groupAvatar provided");
      }

      console.log("ğŸ“ Final conversation data:", conversationData);

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ù‚ÙŠÙ… undefined ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const cleanData = Object.fromEntries(
        Object.entries(conversationData).filter(
          ([key, value]) => value !== undefined
        )
      );

      console.log("ğŸ§¹ Cleaned conversation data:", cleanData);

      const docRef = await addDoc(
        collection(db, this.conversationsCollection),
        cleanData
      );

      console.log("âœ… Conversation created with ID:", docRef.id);
      return docRef.id;
    } catch (error: any) {
      console.error("âŒ Error creating conversation:", error);
      console.error("âŒ Error details:", {
        participants,
        isGroup,
        groupName,
        groupAvatar,
        error: error.message,
      });
      throw error;
    }
  }

  // Ø¬Ù„Ø¨ Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  static async getUserConversations(userId: string): Promise<Conversation[]> {
    try {
      const q = query(
        collection(db, this.conversationsCollection),
        where("participants", "array-contains", userId)
        // Ø¥Ø²Ø§Ù„Ø© orderBy Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù€ composite index
      );

      const querySnapshot = await getDocs(q);
      const conversations = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Conversation[];

      // ØªØ±ØªÙŠØ¨ Ù…Ø­Ù„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Firestore orderBy
      return conversations.sort((a, b) => {
        const aTime = a.updatedAt?.toDate?.() || new Date(0);
        const bTime = b.updatedAt?.toDate?.() || new Date(0);
        return bTime.getTime() - aTime.getTime(); // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ
      });
    } catch (error: any) {
      console.error("Error getting user conversations:", error);
      throw error;
    }
  }

  // Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  static subscribeToUserConversations(
    userId: string,
    callback: (conversations: Conversation[]) => void
  ) {
    const q = query(
      collection(db, this.conversationsCollection),
      where("participants", "array-contains", userId)
      // Ø¥Ø²Ø§Ù„Ø© orderBy Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù€ composite index
    );

    return onSnapshot(q, (querySnapshot) => {
      const conversations = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Conversation[];

      // ØªØ±ØªÙŠØ¨ Ù…Ø­Ù„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Firestore orderBy
      const sortedConversations = conversations.sort((a, b) => {
        const aTime = a.updatedAt?.toDate?.() || new Date(0);
        const bTime = b.updatedAt?.toDate?.() || new Date(0);
        return bTime.getTime() - aTime.getTime(); // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ
      });

      callback(sortedConversations);
    });
  }

  // Ø¬Ù„Ø¨ Ø±Ø³Ø§Ø¦Ù„ Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ÙŠÙ†Ø©
  static async getConversationMessages(
    conversationId: string
  ): Promise<Message[]> {
    try {
      const q = query(
        collection(
          db,
          this.conversationsCollection,
          conversationId,
          this.messagesCollection
        )
        // Ø¥Ø²Ø§Ù„Ø© orderBy Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù€ composite index
      );

      const querySnapshot = await getDocs(q);
      const messages = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Message[];

      // ØªØ±ØªÙŠØ¨ Ù…Ø­Ù„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Firestore orderBy
      return messages.sort((a, b) => {
        const aTime = a.timestamp?.toDate?.() || new Date(0);
        const bTime = b.timestamp?.toDate?.() || new Date(0);
        return aTime.getTime() - bTime.getTime(); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„
      });
    } catch (error: any) {
      console.error("Error getting conversation messages:", error);
      throw error;
    }
  }

  // Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø±Ø³Ø§Ø¦Ù„ Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ÙŠÙ†Ø©
  static subscribeToConversationMessages(
    conversationId: string,
    callback: (messages: Message[]) => void
  ) {
    const q = query(
      collection(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection
      )
      // Ø¥Ø²Ø§Ù„Ø© orderBy Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù€ composite index
    );

    return onSnapshot(q, (querySnapshot) => {
      const messages = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Message[];

      // ØªØ±ØªÙŠØ¨ Ù…Ø­Ù„ÙŠ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Firestore orderBy
      const sortedMessages = messages.sort((a, b) => {
        const aTime = a.timestamp?.toDate?.() || new Date(0);
        const bTime = b.timestamp?.toDate?.() || new Date(0);
        return aTime.getTime() - bTime.getTime(); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ù„Ù„Ø±Ø³Ø§Ø¦Ù„
      });

      callback(sortedMessages);
    });
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
  static async sendMessage(
    conversationId: string,
    senderId: string,
    content: string,
    type: "text" | "file" | "image" = "text",
    fileUrl?: string,
    fileName?: string
  ): Promise<string> {
    try {
      const messageData: Omit<Message, "id"> = {
        senderId,
        content,
        timestamp: serverTimestamp(),
        type,
        isRead: false,
      };

      // Ø¥Ø¶Ø§ÙØ© fileUrl ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      if (fileUrl && fileUrl.trim() !== "") {
        messageData.fileUrl = fileUrl;
      }

      // Ø¥Ø¶Ø§ÙØ© fileName ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
      if (fileName && fileName.trim() !== "") {
        messageData.fileName = fileName;
      }

      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      const messageRef = await addDoc(
        collection(
          db,
          this.conversationsCollection,
          conversationId,
          this.messagesCollection
        ),
        messageData
      );

      // ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      await updateDoc(conversationRef, {
        lastMessage: {
          ...messageData,
          id: messageRef.id,
        },
        updatedAt: serverTimestamp(),
      });

      return messageRef.id;
    } catch (error: any) {
      console.error("Error sending message:", error);
      throw error;
    }
  }

  // Ø¥Ø±Ø³Ø§Ù„ Ù…Ù„Ù
  static async sendFile(
    conversationId: string,
    senderId: string,
    file: File
  ): Promise<string> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù
      if (!FileService.isAllowedFileType(file)) {
        throw new Error("Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡");
      }

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
      if (!FileService.isFileSizeValid(file, 10)) {
        throw new Error("Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙŠØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ (10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)");
      }

      // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Firebase Storage
      const fileUrl = await FileService.uploadFile(
        file,
        `conversations/${conversationId}/files`
      );

      const fileName = file.name;
      const fileSize = file.size;
      const content = `ğŸ“ ${fileName} (${this.formatFileSize(fileSize)})`;

      return await this.sendMessage(
        conversationId,
        senderId,
        content,
        "file",
        fileUrl, // Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù„Ù Ø§Ù„ÙØ¹Ù„ÙŠ
        fileName
      );
    } catch (error: any) {
      console.error("Error sending file:", error);
      throw error;
    }
  }

  // ØªÙ†Ø³ÙŠÙ‚ Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
  private static formatFileSize(bytes: number): string {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }

  // Ø­Ø°Ù Ø±Ø³Ø§Ù„Ø©
  static async deleteMessage(
    conversationId: string,
    messageId: string,
    userId: string
  ): Promise<void> {
    try {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ù…Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
      const messageRef = doc(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection,
        messageId
      );

      const messageSnap = await getDoc(messageRef);
      if (!messageSnap.exists()) {
        throw new Error("Message not found");
      }

      const messageData = messageSnap.data() as Message;
      if (messageData.senderId !== userId) {
        throw new Error("You can only delete your own messages");
      }

      await deleteDoc(messageRef);

      // ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø°ÙˆÙØ© Ù‡ÙŠ Ø§Ù„Ø£Ø®ÙŠØ±Ø©
      const messages = await this.getConversationMessages(conversationId);
      const lastMessage = messages[messages.length - 1];

      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      await updateDoc(conversationRef, {
        lastMessage: lastMessage || null,
        updatedAt: serverTimestamp(),
      });
    } catch (error: any) {
      console.error("Error deleting message:", error);
      throw error;
    }
  }

  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
  static async markMessagesAsRead(
    conversationId: string,
    userId: string
  ): Promise<void> {
    try {
      const messagesRef = collection(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection
      );

      // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØªØµÙÙŠØªÙ‡Ø§ Ù…Ø­Ù„ÙŠØ§Ù‹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø© Ù„Ù€ composite index
      const q = query(messagesRef);
      const querySnapshot = await getDocs(q);

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø±Ø³Ø§Ø¦Ù„ Ù„ØªØ­Ø¯ÙŠØ«Ù‡Ø§
      const messagesToUpdate = querySnapshot.docs.filter((doc) => {
        const messageData = doc.data() as Message;
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ Ù„Ù… ÙŠØ±Ø³Ù„Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØºÙŠØ± Ù…Ù‚Ø±ÙˆØ¡Ø©
        return messageData.senderId !== userId && !messageData.isRead;
      });

      // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø±Ø³Ø§Ø¦Ù„ Ù„ØªØ­Ø¯ÙŠØ«Ù‡Ø§ØŒ Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¦Ø§Ù‹
      if (messagesToUpdate.length === 0) {
        return;
      }

      const batch = writeBatch(db);

      messagesToUpdate.forEach((doc) => {
        batch.update(doc.ref, { isRead: true });
      });

      await batch.commit();

      // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø© ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      try {
        const conversationRef = doc(
          db,
          this.conversationsCollection,
          conversationId
        );
        await updateDoc(conversationRef, {
          unreadCount: 0,
        });
      } catch (conversationError) {
        // ØªØ¬Ø§Ù‡Ù„ Ø®Ø·Ø£ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø¶Ø±ÙˆØ±ÙŠØ§Ù‹
        console.log(
          "Warning: Could not update conversation unread count:",
          conversationError
        );
      }
    } catch (error: any) {
      console.error("Error marking messages as read:", error);
      // Ù„Ø§ Ù†Ø±ÙŠØ¯ Ø£Ù† Ù†ÙˆÙ‚Ù Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø³Ø¨Ø¨ Ù‡Ø°Ø§ Ø§Ù„Ø®Ø·Ø£
      // throw error;
    }
  }

  // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø­Ø§Ø¯Ø«Ø© Ø¨ÙŠÙ† Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  static async findConversationBetweenUsers(
    userId1: string,
    userId2: string
  ): Promise<Conversation | null> {
    try {
      const q = query(
        collection(db, this.conversationsCollection),
        where("participants", "array-contains", userId1),
        where("isGroup", "==", false)
      );

      const querySnapshot = await getDocs(q);
      const conversation = querySnapshot.docs.find((doc) => {
        const data = doc.data() as Conversation;
        return data.participants.includes(userId2);
      });

      if (conversation) {
        return {
          id: conversation.id,
          ...conversation.data(),
        } as Conversation;
      }

      return null;
    } catch (error: any) {
      console.error("Error finding conversation between users:", error);
      throw error;
    }
  }

  // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
  static async searchMessages(
    conversationId: string,
    searchTerm: string
  ): Promise<Message[]> {
    try {
      const messagesRef = collection(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection
      );

      const q = query(messagesRef); // Ø¥Ø²Ø§Ù„Ø© orderBy
      const querySnapshot = await getDocs(q);

      const messages = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as Message[];

      // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
      const filteredMessages = messages.filter((message) =>
        message.content.toLowerCase().includes(searchTerm.toLowerCase())
      );

      // ØªØ±ØªÙŠØ¨ Ù…Ø­Ù„ÙŠ
      return filteredMessages.sort((a, b) => {
        const aTime = a.timestamp?.toDate?.() || new Date(0);
        const bTime = b.timestamp?.toDate?.() || new Date(0);
        return bTime.getTime() - aTime.getTime(); // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ Ù„Ù„Ø¨Ø­Ø«
      });
    } catch (error: any) {
      console.error("Error searching messages:", error);
      throw error;
    }
  }

  // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„Ù‰ Ù…Ø¬Ù…ÙˆØ¹Ø©
  static async addUserToGroup(
    conversationId: string,
    userId: string,
    addedBy: string
  ): Promise<void> {
    try {
      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      const conversationSnap = await getDoc(conversationRef);

      if (!conversationSnap.exists()) {
        throw new Error("Conversation not found");
      }

      const conversationData = conversationSnap.data() as Conversation;
      if (!conversationData.isGroup) {
        throw new Error("This is not a group conversation");
      }

      if (!conversationData.participants.includes(addedBy)) {
        throw new Error("You are not a member of this group");
      }

      if (conversationData.participants.includes(userId)) {
        throw new Error("User is already a member of this group");
      }

      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
      await updateDoc(conversationRef, {
        participants: [...conversationData.participants, userId],
        updatedAt: serverTimestamp(),
      });

      // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ø´Ø¹Ø§Ø±
      await this.sendMessage(
        conversationId,
        "system",
        `ØªÙ… Ø¥Ø¶Ø§ÙØ© ${userId} Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨ÙˆØ§Ø³Ø·Ø© ${addedBy}`,
        "text"
      );
    } catch (error: any) {
      console.error("Error adding user to group:", error);
      throw error;
    }
  }

  // Ø¥Ø²Ø§Ù„Ø© Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø©
  static async removeUserFromGroup(
    conversationId: string,
    userId: string,
    removedBy: string
  ): Promise<void> {
    try {
      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      const conversationSnap = await getDoc(conversationRef);

      if (!conversationSnap.exists()) {
        throw new Error("Conversation not found");
      }

      const conversationData = conversationSnap.data() as Conversation;
      if (!conversationData.isGroup) {
        throw new Error("This is not a group conversation");
      }

      if (!conversationData.participants.includes(removedBy)) {
        throw new Error("You are not a member of this group");
      }

      if (!conversationData.participants.includes(userId)) {
        throw new Error("User is not a member of this group");
      }

      // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
      const updatedParticipants = conversationData.participants.filter(
        (p) => p !== userId
      );
      await updateDoc(conversationRef, {
        participants: updatedParticipants,
        updatedAt: serverTimestamp(),
      });

      // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ø´Ø¹Ø§Ø±
      await this.sendMessage(
        conversationId,
        "system",
        `ØªÙ… Ø¥Ø²Ø§Ù„Ø© ${userId} Ù…Ù† Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨ÙˆØ§Ø³Ø·Ø© ${removedBy}`,
        "text"
      );
    } catch (error: any) {
      console.error("Error removing user from group:", error);
      throw error;
    }
  }

  // Ø­Ø°Ù Ù…Ø­Ø§Ø¯Ø«Ø©
  static async deleteConversation(conversationId: string): Promise<void> {
    try {
      // Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      const messagesRef = collection(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection
      );
      const messagesSnapshot = await getDocs(messagesRef);
      const batch = writeBatch(db);

      messagesSnapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });

      // Ø­Ø°Ù Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ù†ÙØ³Ù‡Ø§
      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      batch.delete(conversationRef);

      await batch.commit();
    } catch (error: any) {
      console.error("Error deleting conversation:", error);
      throw error;
    }
  }

  // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
  static async getConversationStats(conversationId: string): Promise<{
    totalMessages: number;
    totalParticipants: number;
    lastActivity: any;
  }> {
    try {
      const messagesRef = collection(
        db,
        this.conversationsCollection,
        conversationId,
        this.messagesCollection
      );

      const messagesSnapshot = await getDocs(messagesRef);
      const conversationRef = doc(
        db,
        this.conversationsCollection,
        conversationId
      );
      const conversationSnap = await getDoc(conversationRef);

      if (!conversationSnap.exists()) {
        throw new Error("Conversation not found");
      }

      const conversationData = conversationSnap.data() as Conversation;

      return {
        totalMessages: messagesSnapshot.size,
        totalParticipants: conversationData.participants.length,
        lastActivity: conversationData.updatedAt,
      };
    } catch (error: any) {
      console.error("Error getting conversation stats:", error);
      throw error;
    }
  }
}

// ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø¯ÙˆØ§Ù„ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ© - Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙ‚Ø·

// Ø¯Ø§Ù„Ø© Ù„ÙØ­Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Firestore (Ù„Ù„ØªØ·ÙˆÙŠØ± ÙÙ‚Ø·)
export const checkFirestoreData = async () => {
  try {
    console.log("ğŸ” Checking Firestore data...");

    // ÙØ­Øµ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    const usersSnapshot = await getDocs(collection(db, "users"));
    console.log("ğŸ‘¥ Users count:", usersSnapshot.size);

    // ÙØ­Øµ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
    const projectsSnapshot = await getDocs(collection(db, "projects"));
    console.log("ğŸ“ Projects count:", projectsSnapshot.size);

    // ÙØ­Øµ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
    const conversationsSnapshot = await getDocs(collection(db, "conversations"));
    console.log("ğŸ’¬ Conversations count:", conversationsSnapshot.size);

  } catch (error) {
    console.error("âŒ Error checking Firestore data:", error);
  }
};

// Ø¯Ø§Ù„Ø© Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¨ÙˆØ§Ø³Ø·Ø© Ù…Ø´Ø±Ù
export const createProjectBySupervisor = async (
  supervisorId: string,
  projectData: {
    title: string;
    description: string;
    type: string;
    dueDate: string;
    students: string[];
  }
) => {
  try {
    const project = {
      ...projectData,
      status: "planning" as const,
      priority: "medium" as const,
      progress: 0,
      supervisorId,
      studentId: projectData.students[0] || "", // Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
      todoList: [],
      tags: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const projectId = await ProjectService.createProject(project);

    // Ø¥Ø¶Ø§ÙØ© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
    for (const studentId of projectData.students) {
      await ProjectService.addStudentToProject(projectId, studentId);
    }

    return { success: true, projectId };
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:", error);
    return { success: false, error };
  }
};

// Ø¯Ø§Ù„Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø·Ø§Ù„Ø¨
export const manageTaskByStudent = async (
  projectId: string,
  taskData: {
    id?: string;
    title: string;
    description: string;
    dueDate: string;
    priority: "low" | "medium" | "high";
    completed?: boolean;
    assignedTo: string;
  }
) => {
  try {
    const task = {
      id: taskData.id || `task-${Date.now()}`,
      title: taskData.title,
      description: taskData.description,
      completed: taskData.completed || false,
      dueDate: taskData.dueDate,
      assignedTo: taskData.assignedTo,
      priority: taskData.priority,
      createdAt: new Date().toISOString(),
      completedAt: taskData.completed ? new Date().toISOString() : undefined,
    };

    if (taskData.id) {
      // ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
      await ProjectService.updateTask(projectId, task);
    } else {
      // Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©
      await ProjectService.addTask(projectId, task);
    }

    return { success: true, task };
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ù…Ø©:", error);
    return { success: false, error };
  }
};
        email: "ahmed@university.edu",
        role: "student",
        department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
        specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨",
        avatar: "Ø£Ø­",
        phone: "+966501234567",
        studentId: "2021001",
      });

      console.log("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ");
    } catch (error) {
      console.log("âš ï¸ Ø­Ø³Ø§Ø¨ Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø·Ø£:", error);
    }

    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Firebase Auth
      await createUserWithEmailAndPassword(
        auth,
        "sara@university.edu",
        "Sara123!"
      );

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Firestore
      await UserService.createUser({
        name: "Ø³Ø§Ø±Ø© Ø®Ø§Ù„Ø¯ Ù…Ø­Ù…Ø¯",
        email: "sara@university.edu",
        role: "student",
        department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¢Ø¯Ø§Ø¨",
        specialization: "Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
        avatar: "Ø³Ø±",
        phone: "+966504567890",
        studentId: "2021004",
      });

      console.log("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø³Ø§Ø±Ø© Ø®Ø§Ù„Ø¯ Ù…Ø­Ù…Ø¯");
    } catch (error) {
      console.log("âš ï¸ Ø­Ø³Ø§Ø¨ Ø³Ø§Ø±Ø© Ø®Ø§Ù„Ø¯ Ù…Ø­Ù…Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø·Ø£:", error);
    }

    await UserService.createUser({
      name: "Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ Ø­Ø³Ù†",
      email: "mohammed@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
      specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ§Øª",
      avatar: "Ù…Ø­",
      phone: "+966502345678",
      studentId: "2021002",
    });

    await UserService.createUser({
      name: "ÙØ§Ø·Ù…Ø© Ø£Ø­Ù…Ø¯ Ø³Ø¹ÙŠØ¯",
      email: "fatima@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙ…",
      specialization: "Ø¹Ù„ÙˆÙ… Ø§Ù„Ø­Ø§Ø³ÙˆØ¨",
      avatar: "ÙØª",
      phone: "+966503456789",
      studentId: "2021003",
    });

    await UserService.createUser({
      name: "Ø¹Ù„ÙŠ Ù…Ø­Ù…Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡",
      email: "ali@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
      specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø´Ø¨ÙƒØ§Øª",
      avatar: "Ø¹Ù„",
      phone: "+966504567890",
      studentId: "2021005",
    });

    await UserService.createUser({
      name: "Ù†ÙˆØ±Ø§ Ø³Ø¹Ø¯ Ù…Ø­Ù…Ø¯",
      email: "nora@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¢Ø¯Ø§Ø¨",
      specialization: "Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©",
      avatar: "Ù†Ùˆ",
      phone: "+966505678901",
      studentId: "2021006",
    });

    await UserService.createUser({
      name: "ÙŠÙˆØ³Ù Ø£Ø­Ù…Ø¯ Ø®Ø§Ù„Ø¯",
      email: "yousef@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙ…",
      specialization: "Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª",
      avatar: "ÙŠÙˆ",
      phone: "+966506789012",
      studentId: "2021007",
    });

    await UserService.createUser({
      name: "Ø±ÙŠÙ… Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ",
      email: "reem@university.edu",
      role: "student",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
      specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨",
      avatar: "Ø±ÙŠ",
      phone: "+966507890123",
      studentId: "2021008",
    });

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙÙŠÙ†
    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Firebase Auth
      await createUserWithEmailAndPassword(
        auth,
        "dr.khalid@university.edu",
        "Khalid123!"
      );

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Firestore
      await UserService.createUser({
        name: "Ø¯. Ø®Ø§Ù„Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯",
        email: "dr.khalid@university.edu",
        role: "supervisor",
        department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
        specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ§Øª",
        avatar: "Ø®Ø§",
        phone: "+966506789012",
        supervisorId: "SUP001",
      });

      console.log("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¯. Ø®Ø§Ù„Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯");
    } catch (error) {
      console.log(
        "âš ï¸ Ø­Ø³Ø§Ø¨ Ø¯. Ø®Ø§Ù„Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø·Ø£:",
        error
      );
    }

    await UserService.createUser({
      name: "Ø¯. Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ ØµØ§Ù„Ø­",
      email: "dr.ahmed@university.edu",
      role: "supervisor",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ù‡Ù†Ø¯Ø³Ø©",
      specialization: "Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨",
      avatar: "Ø£Ø­",
      phone: "+966507890123",
      supervisorId: "SUP002",
    });

    await UserService.createUser({
      name: "Ø¯. ÙØ§Ø·Ù…Ø© Ø¹Ù„ÙŠ Ø­Ø³Ù†",
      email: "dr.fatima@university.edu",
      role: "supervisor",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¢Ø¯Ø§Ø¨",
      specialization: "Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
      avatar: "ÙØª",
      phone: "+966508901234",
      supervisorId: "SUP003",
    });

    await UserService.createUser({
      name: "Ø¯. Ù…Ø­Ù…Ø¯ Ø³Ø¹Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡",
      email: "dr.mohammed@university.edu",
      role: "supervisor",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¹Ù„ÙˆÙ…",
      specialization: "Ø¹Ù„ÙˆÙ… Ø§Ù„Ø­Ø§Ø³ÙˆØ¨",
      avatar: "Ù…Ø­",
      phone: "+966509012345",
      supervisorId: "SUP004",
    });

    await UserService.createUser({
      name: "Ø¯. Ø³Ø§Ø±Ø© Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯",
      email: "dr.sara@university.edu",
      role: "supervisor",
      department: "ÙƒÙ„ÙŠØ© Ø§Ù„Ø¢Ø¯Ø§Ø¨",
      specialization: "Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©",
      avatar: "Ø³Ø±",
      phone: "+966500123456",
      supervisorId: "SUP005",
    });

    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø¯Ø§Ø±ÙŠ
    try {
      // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Firebase Auth
      await createUserWithEmailAndPassword(
        auth,
        "admin.abdullah@university.edu",
        "Admin123!"
      );

      // Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Firestore
      await UserService.createUser({
        name: "Ø£. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯ ØµØ§Ù„Ø­",
        email: "admin.abdullah@university.edu",
        role: "admin",
        department: "Ø¥Ø¯Ø§Ø±Ø© Ø´Ø¤ÙˆÙ† Ø§Ù„Ø·Ù„Ø§Ø¨",
        specialization: "Ø¥Ø¯Ø§Ø±Ø© Ø£ÙƒØ§Ø¯ÙŠÙ…ÙŠØ©",
        avatar: "Ø¹Ø¨",
        phone: "+966501111111",
      });

      console.log("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø£. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯ ØµØ§Ù„Ø­");
    } catch (error) {
      console.log(
        "âš ï¸ Ø­Ø³Ø§Ø¨ Ø£. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯ ØµØ§Ù„Ø­ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø·Ø£:",
        error
      );
    }

    console.log("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!");
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø£ÙˆÙ„ÙŠØ©:", error);
  }
};

// Ø¯Ø§Ù„Ø© Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
const initializeProjects = async () => {
  try {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø´Ø§Ø±ÙŠØ¹
    const projectsSnapshot = await getDocs(collection(db, "projects"));
    if (!projectsSnapshot.empty) {
      console.log("Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ØŒ ØªØ®Ø·ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©");
      return;
    }

    console.log("Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø§Ø±ÙŠØ¹ Ø£ÙˆÙ„ÙŠØ©...");

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ ØªØ¬Ø±ÙŠØ¨ÙŠ
    await ProjectService.createProject({
      title: "ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ´ÙÙŠØ§Øª Ø§Ù„Ø°ÙƒÙŠ",
      description:
        "ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ´ÙÙŠØ§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„ØªØ­Ø³ÙŠÙ† ÙƒÙØ§Ø¡Ø© Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ø·Ø¨ÙŠØ© ÙˆØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¨Ø´Ø±ÙŠØ©.",
      type: "Ù…Ø´Ø±ÙˆØ¹ ØªØ®Ø±Ø¬",
      status: "active",
      priority: "high",
      progress: 65,
      studentId: "student-1",
      supervisorId: "supervisor-1",
      todoList: [
        {
          id: "todo-1-1",
          title: "ØªØ­Ù„ÙŠÙ„ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…",
          description: "Ø¯Ø±Ø§Ø³Ø© Ø§Ø­ØªÙŠØ§Ø¬Ø§Øª Ø§Ù„Ù…Ø³ØªØ´ÙÙ‰ ÙˆØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„ÙˆØ¸ÙŠÙÙŠØ©",
          completed: true,
          dueDate: "2024-01-15",
          assignedTo: "student-1",
          priority: "high",
          createdAt: "2024-01-01",
          completedAt: "2024-01-10",
        },
        {
          id: "todo-1-2",
          title: "ØªØµÙ…ÙŠÙ… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
          description: "ØªØµÙ…ÙŠÙ… Ù‡ÙŠÙƒÙ„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¹Ù„Ø§Ù‚Ø§Øª Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„",
          completed: true,
          dueDate: "2024-01-30",
          assignedTo: "student-1",
          priority: "high",
          createdAt: "2024-01-01",
          completedAt: "2024-01-25",
        },
        {
          id: "todo-1-3",
          title: "ØªØ·ÙˆÙŠØ± ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…",
          description: "ØªØµÙ…ÙŠÙ… ÙˆØªØ·ÙˆÙŠØ± ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ù†Ø¸Ø§Ù…",
          completed: true,
          dueDate: "2024-02-15",
          assignedTo: "student-1",
          priority: "medium",
          createdAt: "2024-01-01",
          completedAt: "2024-02-10",
        },
        {
          id: "todo-1-4",
          title: "ØªØ·ÙˆÙŠØ± Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
          description: "ØªØ·ÙˆÙŠØ± Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù„Ù„ØªÙ†Ø¨Ø¤ Ø¨Ø§Ù„Ø£Ù…Ø±Ø§Ø¶ ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©",
          completed: false,
          dueDate: "2024-03-01",
          assignedTo: "student-1",
          priority: "high",
          createdAt: "2024-01-01",
        },
        {
          id: "todo-1-5",
          title: "Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù…",
          description: "Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ù†Ø¸Ø§Ù… ÙˆØªØµØ­ÙŠØ­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡",
          completed: false,
          dueDate: "2024-03-15",
          assignedTo: "student-1",
          priority: "medium",
          createdAt: "2024-01-01",
        },
        {
          id: "todo-1-6",
          title: "ÙƒØªØ§Ø¨Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ",
          description: "Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ù…Ø´Ø±ÙˆØ¹",
          completed: false,
          dueDate: "2024-04-01",
          assignedTo: "student-1",
          priority: "low",
          createdAt: "2024-01-01",
        },
      ],
      tags: ["Ø¨Ø±Ù…Ø¬Ø©", "Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª", "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ", "Ø·Ø¨ Ø¹Ø§Ù…"],
      dueDate: "2024-04-15",
    });

    await ProjectService.createProject({
      title: "Ø¯Ø±Ø§Ø³Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØºØ°ÙŠØ© Ø¹Ù„Ù‰ Ù†Ù…Ùˆ Ø§Ù„Ø£Ø·ÙØ§Ù„",
      description:
        "Ø¨Ø­Ø« Ø¹Ù„Ù…ÙŠ Ù„Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„ØªØºØ°ÙŠØ© ÙˆÙ†Ù…Ùˆ Ø§Ù„Ø£Ø·ÙØ§Ù„ ÙÙŠ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø¹Ù…Ø±ÙŠØ© Ø§Ù„Ù…Ø®ØªÙ„ÙØ©.",
      type: "Ø¨Ø­Ø« Ø¹Ù„Ù…ÙŠ",
      status: "active",
      priority: "medium",
      progress: 40,
      studentId: "student-2",
      supervisorId: "supervisor-2",
      todoList: [
        {
          id: "todo-2-1",
          title: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø£Ø¯Ø¨ÙŠØ§Øª Ø§Ù„Ø¹Ù„Ù…ÙŠØ©",
          description:
            "Ø¬Ù…Ø¹ ÙˆÙ…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¯Ø±Ø§Ø³Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ÙÙŠ Ù…Ø¬Ø§Ù„ Ø§Ù„ØªØºØ°ÙŠØ© ÙˆÙ†Ù…Ùˆ Ø§Ù„Ø£Ø·ÙØ§Ù„",
          completed: true,
          dueDate: "2024-01-20",
          assignedTo: "student-2",
          priority: "high",
          createdAt: "2024-01-05",
          completedAt: "2024-01-18",
        },
        {
          id: "todo-2-2",
          title: "ØªØµÙ…ÙŠÙ… Ø§Ù„Ø¯Ø±Ø§Ø³Ø©",
          description: "ØªØ­Ø¯ÙŠØ¯ Ù…Ù†Ù‡Ø¬ÙŠØ© Ø§Ù„Ø¨Ø­Ø« ÙˆØ¹ÙŠÙ†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³Ø©",
          completed: true,
          dueDate: "2024-02-01",
          assignedTo: "student-2",
          priority: "high",
          createdAt: "2024-01-05",
          completedAt: "2024-01-28",
        },
        {
          id: "todo-2-3",
          title: "Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
          description: "Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ø¨Ù„Ø§Øª ÙˆØ¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø¹ÙŠÙ†Ø©",
          completed: false,
          dueDate: "2024-03-01",
          assignedTo: "student-2",
          priority: "high",
          createdAt: "2024-01-05",
        },
        {
          id: "todo-2-4",
          title: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
          description: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ø­ØµØ§Ø¦ÙŠØ§Ù‹ ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù†ØªØ§Ø¦Ø¬",
          completed: false,
          dueDate: "2024-03-15",
          assignedTo: "student-2",
          priority: "medium",
          createdAt: "2024-01-05",
        },
        {
          id: "todo-2-5",
          title: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨Ø­Ø«",
          description: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¹Ù„Ù…ÙŠ Ù…Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„ØªÙˆØµÙŠØ§Øª",
          completed: false,
          dueDate: "2024-04-01",
          assignedTo: "student-2",
          priority: "medium",
          createdAt: "2024-01-05",
        },
      ],
      tags: ["Ø·Ø¨ Ø¹Ø§Ù…", "Ø·Ø¨ Ø§Ù„Ø£Ø·ÙØ§Ù„", "ØµØ­Ø© Ø¹Ø§Ù…Ø©", "Ø¥Ø­ØµØ§Ø¡"],
      dueDate: "2024-04-15",
    });

    await ProjectService.createProject({
      title: "ØªØ·ÙˆÙŠØ± Ù…ÙˆØ§Ø¯ Ù†Ø§Ù†ÙˆÙŠØ© Ù„ØªÙ†Ù‚ÙŠØ© Ø§Ù„Ù…ÙŠØ§Ù‡",
      description:
        "ØªØµÙ…ÙŠÙ… ÙˆØªØ·ÙˆÙŠØ± Ù…ÙˆØ§Ø¯ Ù†Ø§Ù†ÙˆÙŠØ© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªÙ†Ù‚ÙŠØ© Ø§Ù„Ù…ÙŠØ§Ù‡ Ù…Ù† Ø§Ù„Ù…Ù„ÙˆØ«Ø§Øª Ø§Ù„Ø¹Ø¶ÙˆÙŠØ© ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù† Ø§Ù„Ø«Ù‚ÙŠÙ„Ø©.",
      type: "Ø¨Ø­Ø« Ø¹Ù„Ù…ÙŠ",
      status: "active",
      priority: "high",
      progress: 75,
      studentId: "student-3",
      supervisorId: "supervisor-3",
      todoList: [
        {
          id: "todo-3-1",
          title: "ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù†Ø§Ù†ÙˆÙŠØ©",
          description: "ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù†Ø§Ù†ÙˆÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·Ø±Ù‚ ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ© Ù…Ø®ØªÙ„ÙØ©",
          completed: true,
          dueDate: "2024-01-10",
          assignedTo: "student-3",
          priority: "high",
          createdAt: "2024-01-02",
          completedAt: "2024-01-08",
        },
        {
          id: "todo-3-2",
          title: "ØªÙˆØµÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø¯",
          description: "ØªÙˆØµÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù†Ø§Ù†ÙˆÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©",
          completed: true,
          dueDate: "2024-01-25",
          assignedTo: "student-3",
          priority: "high",
          createdAt: "2024-01-02",
          completedAt: "2024-01-22",
        },
        {
          id: "todo-3-3",
          title: "Ø§Ø®ØªØ¨Ø§Ø± ÙƒÙØ§Ø¡Ø© Ø§Ù„ØªÙ†Ù‚ÙŠØ©",
          description: "Ø§Ø®ØªØ¨Ø§Ø± Ù‚Ø¯Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ Ø¹Ù„Ù‰ ØªÙ†Ù‚ÙŠØ© Ø§Ù„Ù…ÙŠØ§Ù‡ Ù…Ù† Ø§Ù„Ù…Ù„ÙˆØ«Ø§Øª",
          completed: true,
          dueDate: "2024-02-10",
          assignedTo: "student-3",
          priority: "high",
          createdAt: "2024-01-02",
          completedAt: "2024-02-05",
        },
        {
          id: "todo-3-4",
          title: "ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡",
          description: "ØªØ­Ø³ÙŠÙ† ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ¯Ø±Ø§Ø³Ø© Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ù…Ø¤Ø«Ø±Ø©",
          completed: false,
          dueDate: "2024-02-25",
          assignedTo: "student-3",
          priority: "medium",
          createdAt: "2024-01-02",
        },
        {
          id: "todo-3-5",
          title: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨Ø­Ø«",
          description: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¹Ù„Ù…ÙŠ Ù…Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª",
          completed: false,
          dueDate: "2024-03-15",
          assignedTo: "student-3",
          priority: "medium",
          createdAt: "2024-01-02",
        },
      ],
      tags: ["ÙƒÙŠÙ…ÙŠØ§Ø¡", "ÙƒÙŠÙ…ÙŠØ§Ø¡ Ø­ÙŠÙˆÙŠØ©", "Ø¹Ù„ÙˆÙ… Ø¨ÙŠØ¦ÙŠØ©", "Ù‡Ù†Ø¯Ø³Ø© ÙƒÙŠÙ…ÙŠØ§Ø¦ÙŠØ©"],
      dueDate: "2024-03-30",
    });

    await ProjectService.createProject({
      title: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø£Ø¯Ø¨ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
      description:
        "ØªØ·ÙˆÙŠØ± Ù†Ø¸Ø§Ù… Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø£Ø¯Ø¨ÙŠØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªÙ‚Ù†ÙŠØ§Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù„ØºØ© Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©.",
      type: "Ù…Ø´Ø±ÙˆØ¹ ØªØ®Ø±Ø¬",
      status: "planning",
      priority: "medium",
      progress: 20,
      studentId: "student-4",
      supervisorId: "supervisor-4",
      todoList: [
        {
          id: "todo-4-1",
          title: "Ø¬Ù…Ø¹ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø£Ø¯Ø¨ÙŠØ©",
          description: "Ø¬Ù…Ø¹ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…ØªÙ†ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø£Ø¯Ø¨ÙŠØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„",
          completed: true,
          dueDate: "2024-01-15",
          assignedTo: "student-4",
          priority: "high",
          createdAt: "2024-01-10",
          completedAt: "2024-01-12",
        },
        {
          id: "todo-4-2",
          title: "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ",
          description: "ØªÙ†Ø¸ÙŠÙ ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ Ù„Ù„ØªØ­Ù„ÙŠÙ„",
          completed: false,
          dueDate: "2024-02-01",
          assignedTo: "student-4",
          priority: "high",
          createdAt: "2024-01-10",
        },
        {
          id: "todo-4-3",
          title: "ØªØ·ÙˆÙŠØ± Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„",
          description: "ØªØ·ÙˆÙŠØ± Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø£Ø¯Ø¨ÙŠØ©",
          completed: false,
          dueDate: "2024-02-15",
          assignedTo: "student-4",
          priority: "high",
          createdAt: "2024-01-10",
        },
        {
          id: "todo-4-4",
          title: "Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù…",
          description: "Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©",
          completed: false,
          dueDate: "2024-03-01",
          assignedTo: "student-4",
          priority: "medium",
          createdAt: "2024-01-10",
        },
        {
          id: "todo-4-5",
          title: "ÙƒØªØ§Ø¨Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±",
          description: "ÙƒØªØ§Ø¨Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ù…Ø´Ø±ÙˆØ¹",
          completed: false,
          dueDate: "2024-03-15",
          assignedTo: "student-4",
          priority: "low",
          createdAt: "2024-01-10",
        },
      ],
      tags: ["Ù„ØºØ© Ø¹Ø±Ø¨ÙŠØ©", "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ", "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù„ØºØ© Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©", "Ø¨Ø±Ù…Ø¬Ø©"],
      dueDate: "2024-03-30",
    });

    await ProjectService.createProject({
      title: "Ø¯Ø±Ø§Ø³Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„ØªØ³ÙˆÙŠÙ‚ Ø§Ù„Ø±Ù‚Ù…ÙŠ Ù„Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù†Ø§Ø´Ø¦Ø©",
      description:
        "ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„ØªØ³ÙˆÙŠÙ‚ Ø§Ù„Ø±Ù‚Ù…ÙŠ Ø§Ù„ÙØ¹Ø§Ù„Ø© Ù„Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù†Ø§Ø´Ø¦Ø© ÙÙŠ Ø§Ù„Ø³ÙˆÙ‚ Ø§Ù„Ù…Ø­Ù„ÙŠ.",
      type: "Ø¯Ø±Ø§Ø³Ø© Ø­Ø§Ù„Ø©",
      status: "review",
      priority: "low",
      progress: 90,
      studentId: "student-5",
      supervisorId: "supervisor-5",
      todoList: [
        {
          id: "todo-5-1",
          title: "Ø¬Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù†Ø§Ø´Ø¦Ø©",
          description:
            "Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù† Ø§Ù„Ø´Ø±ÙƒØ§Øª Ø§Ù„Ù†Ø§Ø´Ø¦Ø© ÙˆØ§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§ØªÙ‡Ø§ Ø§Ù„ØªØ³ÙˆÙŠÙ‚ÙŠØ©",
          completed: true,
          dueDate: "2024-01-20",
          assignedTo: "student-5",
          priority: "high",
          createdAt: "2024-01-15",
          completedAt: "2024-01-18",
        },
        {
          id: "todo-5-2",
          title: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
          description: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù…Ø¹Ø© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ù†Ù…Ø§Ø·",
          completed: true,
          dueDate: "2024-02-05",
          assignedTo: "student-5",
          priority: "high",
          createdAt: "2024-01-15",
          completedAt: "2024-02-01",
        },
        {
          id: "todo-5-3",
          title: "Ù…Ù‚Ø§Ø¨Ù„Ø§Øª Ù…Ø¹ Ø±ÙˆØ§Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„",
          description: "Ø¥Ø¬Ø±Ø§Ø¡ Ù…Ù‚Ø§Ø¨Ù„Ø§Øª Ù…Ø¹ Ø±ÙˆØ§Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„ Ù„Ù…Ø¹Ø±ÙØ© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§ØªÙ‡Ù…",
          completed: true,
          dueDate: "2024-02-20",
          assignedTo: "student-5",
          priority: "medium",
          createdAt: "2024-01-15",
          completedAt: "2024-02-15",
        },
        {
          id: "todo-5-4",
          title: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¯Ø±Ø§Ø³Ø©",
          description: "ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø¯Ø±Ø§Ø³Ø© Ù…Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„ØªÙˆØµÙŠØ§Øª",
          completed: true,
          dueDate: "2024-03-01",
          assignedTo: "student-5",
          priority: "medium",
          createdAt: "2024-01-15",
          completedAt: "2024-02-25",
        },
        {
          id: "todo-5-5",
          title: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ù†Ù‡Ø§Ø¦ÙŠØ©",
          description: "Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù„Ù„Ø¯Ø±Ø§Ø³Ø© Ù‚Ø¨Ù„ Ø§Ù„ØªØ³Ù„ÙŠÙ…",
          completed: false,
          dueDate: "2024-03-10",
          assignedTo: "student-5",
          priority: "low",
          createdAt: "2024-01-15",
        },
      ],
      tags: ["Ø¥Ø¯Ø§Ø±Ø© Ø£Ø¹Ù…Ø§Ù„", "ØªØ³ÙˆÙŠÙ‚", "Ø§Ù‚ØªØµØ§Ø¯", "Ø¥Ø¯Ø§Ø±Ø© Ù…Ø§Ù„ÙŠØ©"],
      dueDate: "2024-03-15",
    });

    console.log("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!");
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©:", error);
  }
};

// Ø¯Ø§Ù„Ø© Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
const initializeConversations = async () => {
  try {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø­Ø§Ø¯Ø«Ø§Øª
    const conversationsSnapshot = await getDocs(
      collection(db, "conversations")
    );
    if (!conversationsSnapshot.empty) {
      console.log("Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ØŒ ØªØ®Ø·ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©");
      return;
    }

    console.log("Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø£ÙˆÙ„ÙŠØ©...");

    // Get user IDs for conversations
    const adminUser = await UserService.getUserByEmail("admin@university.edu");
    const ahmedUser = await UserService.getUserByEmail("ahmed@university.edu");
    const saraUser = await UserService.getUserByEmail("sara@university.edu");

    if (!adminUser || !ahmedUser || !saraUser) {
      console.log("âš ï¸ Some users not found, skipping conversation creation");
      return;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø­Ø§Ø¯Ø«Ø© ÙØ±Ø¯ÙŠØ©
    const conversation1Id = await ChatService.createConversation([
      adminUser.id,
      ahmedUser.id,
    ]);

    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ ØªØ¬Ø±ÙŠØ¨ÙŠØ©
    await ChatService.sendMessage(
      conversation1Id,
      adminUser.id,
      "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¯ÙƒØªÙˆØ± Ø£Ø­Ù…Ø¯ØŒ ÙƒÙŠÙ ÙŠØ³ÙŠØ± Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ØŸ"
    );

    await ChatService.sendMessage(
      conversation1Id,
      ahmedUser.id,
      "Ù…Ø±Ø­Ø¨Ø§Ù‹ØŒ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ÙŠØ³ÙŠØ± Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø². Ø§Ù†ØªÙ‡ÙŠØª Ù…Ù† Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰"
    );

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù…ÙˆØ¹Ø©
    const conversation2Id = await ChatService.createConversation(
      [adminUser.id, ahmedUser.id, saraUser.id],
      true,
      "ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø¨Ø­Ø«ÙŠ",
      "Ù"
    );

    // Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
    await ChatService.sendMessage(
      conversation2Id,
      adminUser.id,
      "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¬Ù…ÙŠØ¹Ø§Ù‹ØŒ Ø³Ù†Ø¹Ù‚Ø¯ Ø§Ø¬ØªÙ…Ø§Ø¹ ØºØ¯Ø§Ù‹ Ø§Ù„Ø³Ø§Ø¹Ø© 2 Ù…Ø³Ø§Ø¡Ù‹"
    );

    await ChatService.sendMessage(
      conversation2Id,
      saraUser.id,
      "Ù…Ù…ØªØ§Ø²ØŒ Ø³Ø£Ø­Ø¶Ø± Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹"
    );

    console.log("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!");
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ©:", error);
  }
};

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ø§Øª Firebase Auth
export const createFirebaseAuthAccounts = async () => {
  try {
    console.log("ğŸ” Creating Firebase Auth accounts...");

    const { createUserWithEmailAndPassword } = await import("firebase/auth");
    const { auth } = await import("../config/firebase");

    const accounts = [
      {
        email: "ahmed@university.edu",
        password: "Ahmed123!",
        name: "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ",
      },
      {
        email: "sara@university.edu",
        password: "Sara123!",
        name: "Ø³Ø§Ø±Ø© Ø®Ø§Ù„Ø¯ Ù…Ø­Ù…Ø¯",
      },
      {
        email: "dr.khalid@university.edu",
        password: "Khalid123!",
        name: "Ø¯. Ø®Ø§Ù„Ø¯ Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯",
      },
      {
        email: "admin.abdullah@university.edu",
        password: "Admin123!",
        name: "Ø£. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ù…Ø­Ù…Ø¯ ØµØ§Ù„Ø­",
      },
    ];

    for (const account of accounts) {
      try {
        await createUserWithEmailAndPassword(
          auth,
          account.email,
          account.password
        );
        console.log(`âœ… Created Firebase Auth account for: ${account.name}`);
      } catch (error: any) {
        if (error.code === "auth/email-already-in-use") {
          console.log(`âš ï¸ Account already exists: ${account.name}`);
        } else {
          console.error(
            `âŒ Error creating account for ${account.name}:`,
            error
          );
        }
      }
    }

    console.log("ğŸ” Firebase Auth accounts creation completed!");
  } catch (error) {
    console.error("âŒ Error creating Firebase Auth accounts:", error);
  }
};

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ ÙˆØ§Ø­Ø¯ Ù„Ù„ØªØ¬Ø±Ø¨Ø©
export const createSingleTestAccount = async () => {
  try {
    console.log("ğŸ” Creating single test account...");

    const { createUserWithEmailAndPassword } = await import("firebase/auth");
    const { auth } = await import("../config/firebase");

    const testAccount = {
      email: "test@university.edu",
      password: "Test123!",
      name: "Ø­Ø³Ø§Ø¨ ØªØ¬Ø±ÙŠØ¨ÙŠ",
    };

    try {
      await createUserWithEmailAndPassword(
        auth,
        testAccount.email,
        testAccount.password
      );
      console.log(`âœ… Created test account: ${testAccount.email}`);
      return {
        success: true,
        email: testAccount.email,
        password: testAccount.password,
      };
    } catch (error: any) {
      if (error.code === "auth/email-already-in-use") {
        console.log(`âš ï¸ Test account already exists: ${testAccount.email}`);
        return {
          success: true,
          email: testAccount.email,
          password: testAccount.password,
        };
      } else {
        console.error(`âŒ Error creating test account:`, error);
        return { success: false, error: error.message };
      }
    }
  } catch (error) {
    console.error("âŒ Error creating test account:", error);
    return { success: false, error: error };
  }
};

// Ø¯Ø§Ù„Ø© Ù„ÙØ­Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Firestore
export const checkFirestoreData = async () => {
  try {
    console.log("ğŸ” Checking Firestore data...");

    // ÙØ­Øµ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
    const usersSnapshot = await getDocs(collection(db, "users"));
    console.log(`ğŸ“Š Found ${usersSnapshot.docs.length} users in Firestore:`);
    usersSnapshot.docs.forEach((doc) => {
      const userData = doc.data();
      console.log(
        `  - ${userData.name} (${userData.email}) - ${userData.role}`
      );
    });

    // ÙØ­Øµ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
    const projectsSnapshot = await getDocs(collection(db, "projects"));
    console.log(
      `ğŸ“Š Found ${projectsSnapshot.docs.length} projects in Firestore:`
    );
    projectsSnapshot.docs.forEach((doc) => {
      const projectData = doc.data();
      console.log(`  - ${projectData.title} (${projectData.status})`);
    });

    // ÙØ­Øµ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª
    const conversationsSnapshot = await getDocs(
      collection(db, "conversations")
    );
    console.log(
      `ğŸ“Š Found ${conversationsSnapshot.docs.length} conversations in Firestore`
    );

    return {
      users: usersSnapshot.docs.length,
      projects: projectsSnapshot.docs.length,
      conversations: conversationsSnapshot.docs.length,
    };
  } catch (error) {
    console.error("âŒ Error checking Firestore data:", error);
    return { users: 0, projects: 0, conversations: 0 };
  }
};

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„Ù‚ÙˆØ© (Ø­Ø°Ù ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡)
export const forceInitializeFirebaseData = async () => {
  try {
    console.log("ğŸ”„ Force initializing Firebase data...");

    // Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ø§Øª Firebase Auth Ø£ÙˆÙ„Ø§Ù‹
    await createFirebaseAuthAccounts();

    // Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
    console.log("ğŸ—‘ï¸ Deleting existing data...");
    const existingUsers = await getDocs(collection(db, "users"));
    console.log(
      `ğŸ—‘ï¸ Found ${existingUsers.docs.length} existing users to delete`
    );

    const batch = writeBatch(db);

    existingUsers.docs.forEach((doc) => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log("ğŸ—‘ï¸ Deleted existing data successfully");

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    console.log("ğŸ”„ Re-creating data...");
    await initializeFirebaseData();
    console.log("âœ… Data re-initialized successfully");
  } catch (error: any) {
    console.error("âŒ Error force initializing Firebase data:", error);
    console.error("âŒ Error details:", {
      message: error?.message || "Unknown error",
      code: error?.code || "No code",
      stack: error?.stack || "No stack",
    });
    throw error;
  }
};

// Ø®Ø¯Ù…Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
export const NotificationService = {
  // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¬Ø¯ÙŠØ¯
  async createNotification(notificationData: {
    recipientId: string;
    title: string;
    message: string;
    type: "info" | "success" | "warning" | "error";
    category: "project" | "message" | "system" | "reminder";
    actionUrl?: string;
    senderId?: string;
    senderName?: string;
    senderAvatar?: string;
  }) {
    try {
      const notificationsRef = collection(db, "notifications");
      const newNotification = {
        ...notificationData,
        isRead: false,
        createdAt: serverTimestamp(),
      };

      const docRef = await addDoc(notificationsRef, newNotification);
      return docRef.id;
    } catch (error) {
      console.error("Error creating notification:", error);
      throw error;
    }
  },

  // Ø¬Ù„Ø¨ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getUserNotifications(userId: string) {
    try {
      const notificationsRef = collection(db, "notifications");
      const q = query(
        notificationsRef,
        where("recipientId", "==", userId),
        orderBy("createdAt", "desc")
      );

      const querySnapshot = await getDocs(q);
      const notifications: any[] = [];

      querySnapshot.forEach((doc) => {
        notifications.push({
          id: doc.id,
          ...doc.data(),
        });
      });

      return notifications;
    } catch (error) {
      console.error("Error getting user notifications:", error);
      throw error;
    }
  },

  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
  async markAsRead(notificationId: string) {
    try {
      const notificationRef = doc(db, "notifications", notificationId);
      await updateDoc(notificationRef, { isRead: true });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      throw error;
    }
  },

  // Ø­Ø°Ù Ø¥Ø´Ø¹Ø§Ø±
  async deleteNotification(notificationId: string) {
    try {
      const notificationRef = doc(db, "notifications", notificationId);
      await deleteDoc(notificationRef);
    } catch (error) {
      console.error("Error deleting notification:", error);
      throw error;
    }
  },

  // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ØªØ¬Ø±ÙŠØ¨ÙŠØ©
  async createSampleNotifications(userId: string) {
    try {
      const sampleNotifications = [
        {
          recipientId: userId,
          title: "Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯ ØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡",
          message: "ØªÙ… ØªØ¹ÙŠÙŠÙ†Ùƒ ÙƒÙ…Ø´Ø±Ù Ø¹Ù„Ù‰ Ù…Ø´Ø±ÙˆØ¹ 'ØªØ·ÙˆÙŠØ± ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹'",
          type: "info" as const,
          category: "project" as const,
          senderId: "admin1",
          senderName: "Ø¯. Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯",
          senderAvatar: "Ø£Ø­",
        },
        {
          recipientId: userId,
          title: "Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©",
          message: "Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨ Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ",
          type: "info" as const,
          category: "message" as const,
          senderId: "student1",
          senderName: "Ù…Ø­Ù…Ø¯ Ø¹Ù„ÙŠ",
          senderAvatar: "Ù…Ø­",
        },
        {
          recipientId: userId,
          title: "ØªØ°ÙƒÙŠØ±: Ù…ÙˆØ¹Ø¯ ØªØ³Ù„ÙŠÙ… Ø§Ù„Ù…Ø´Ø±ÙˆØ¹",
          message: "ØªØ°ÙƒÙŠØ±: Ù…ÙˆØ¹Ø¯ ØªØ³Ù„ÙŠÙ… Ù…Ø´Ø±ÙˆØ¹ 'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª' ØºØ¯Ø§Ù‹",
          type: "warning" as const,
          category: "reminder" as const,
        },
      ];

      const promises = sampleNotifications.map((notification) =>
        NotificationService.createNotification(notification)
      );

      await Promise.all(promises);
      console.log("Sample notifications created successfully");
    } catch (error) {
      console.error("Error creating sample notifications:", error);
      throw error;
    }
  },
};

export const testFirebaseSetup = async () => {
  try {
    console.log("ğŸ§ª Testing Firebase setup...");

    const { auth } = await import("../config/firebase");
    const currentUser = auth.currentUser;

    if (!currentUser) {
      console.log("âš ï¸ No authenticated user found");
      return { success: false, message: "No authenticated user" };
    }

    console.log("âœ… User authenticated:", currentUser.email);

    // Test user document creation/retrieval
    const user = await UserService.ensureUserDocument(currentUser);

    if (user) {
      console.log("âœ… User document exists:", user.name, user.role);
      return {
        success: true,
        message: "Firebase setup working correctly",
        user,
      };
    } else {
      console.log("âŒ Failed to create/retrieve user document");
      return {
        success: false,
        message: "Failed to create/retrieve user document",
      };
    }
  } catch (error) {
    console.error("âŒ Firebase setup test failed:", error);
    return { success: false, message: "Test failed", error };
  }
};

export const debugFirestoreData = async () => {
  try {
    console.log("ğŸ” Debugging Firestore data...");

    const { auth } = await import("../config/firebase");
    const currentUser = auth.currentUser;

    if (!currentUser) {
      console.log("âš ï¸ No authenticated user found");
      return { success: false, message: "No authenticated user" };
    }

    console.log(
      "âœ… User authenticated:",
      currentUser.email,
      "UID:",
      currentUser.uid
    );

    // Check if user document exists
    try {
      const userDoc = await UserService.getUserById(currentUser.uid);
      console.log("ğŸ‘¤ User document:", userDoc);

      if (userDoc) {
        // Test project queries with this user
        console.log("ğŸ§ª Testing project queries with user:", userDoc);

        try {
          const userProjects = await ProjectService.getProjectsByUserRole(
            userDoc
          );
          console.log("ğŸ“‹ User projects count:", userProjects.length);
          console.log("ğŸ“‹ User projects:", userProjects);
        } catch (error) {
          console.log("âŒ Error fetching user projects:", error);
        }
      }
    } catch (error) {
      console.log("âŒ Error fetching user document:", error);
    }

    // Check if user document exists by email
    try {
      const userByEmail = await UserService.getUserByEmail(
        currentUser.email || ""
      );
      console.log("ğŸ“§ User by email:", userByEmail);
    } catch (error) {
      console.log("âŒ Error fetching user by email:", error);
    }

    // Try to get all projects
    try {
      const allProjects = await ProjectService.getAllProjects();
      console.log("ğŸ“‹ All projects count:", allProjects.length);
      if (allProjects.length > 0) {
        console.log("ğŸ“‹ Sample project structure:", {
          id: allProjects[0].id,
          studentId: allProjects[0].studentId,
          supervisorId: allProjects[0].supervisorId,
          title: allProjects[0].title,
          status: allProjects[0].status,
        });
      }
    } catch (error) {
      console.log("âŒ Error fetching all projects:", error);
    }

    // Try to get all users
    try {
      const allUsers = await UserService.getAllUsers();
      console.log("ğŸ‘¥ All users count:", allUsers.length);
      if (allUsers.length > 0) {
        console.log("ğŸ‘¥ Sample user structure:", {
          id: allUsers[0].id,
          email: allUsers[0].email,
          role: allUsers[0].role,
          name: allUsers[0].name,
        });
      }
    } catch (error) {
      console.log("âŒ Error fetching all users:", error);
    }

    return { success: true, message: "Debug completed, check console" };
  } catch (error) {
    console.error("âŒ Debug failed:", error);
    return { success: false, message: "Debug failed", error };
  }
};

export const testBasicFirestoreAccess = async () => {
  try {
    console.log("ğŸ§ª Testing basic Firestore access...");

    const { auth } = await import("../config/firebase");
    const currentUser = auth.currentUser;

    if (!currentUser) {
      console.log("âš ï¸ No authenticated user found");
      return { success: false, message: "No authenticated user" };
    }

    console.log(
      "âœ… User authenticated:",
      currentUser.email,
      "UID:",
      currentUser.uid
    );

    // Test 1: Try to read the users collection
    try {
      const usersSnapshot = await getDocs(collection(db, "users"));
      console.log(
        "âœ… Users collection access: OK, count:",
        usersSnapshot.docs.length
      );
    } catch (error) {
      console.log("âŒ Users collection access failed:", error);
    }

    // Test 2: Try to read the projects collection
    try {
      const projectsSnapshot = await getDocs(collection(db, "projects"));
      console.log(
        "âœ… Projects collection access: OK, count:",
        projectsSnapshot.docs.length
      );
    } catch (error) {
      console.log("âŒ Projects collection access failed:", error);
    }

    // Test 3: Try to read a specific user document
    try {
      const userDoc = await getDoc(doc(db, "users", currentUser.uid));
      console.log(
        "âœ… User document access:",
        userDoc.exists() ? "EXISTS" : "NOT FOUND"
      );
    } catch (error) {
      console.log("âŒ User document access failed:", error);
    }

    return { success: true, message: "Basic Firestore tests completed" };
  } catch (error) {
    console.error("âŒ Basic Firestore test failed:", error);
    return { success: false, message: "Test failed", error };
  }
};

export const comprehensiveFirebaseTest = async () => {
  try {
    console.log("ğŸ§ª Starting comprehensive Firebase test...");

    const { auth } = await import("../config/firebase");
    const currentUser = auth.currentUser;

    if (!currentUser) {
      console.log("âš ï¸ No authenticated user found");
      return { success: false, message: "No authenticated user" };
    }

    console.log(
      "âœ… User authenticated:",
      currentUser.email,
      "UID:",
      currentUser.uid
    );

    const results = {
      userAuth: true,
      userDocument: false,
      basicRead: false,
      projectRead: false,
      userRead: false,
      conversationRead: false,
      messageRead: false,
    };

    // Test 1: User document
    try {
      const userDoc = await UserService.getUserById(currentUser.uid);
      if (userDoc) {
        console.log("âœ… User document exists:", userDoc.name, userDoc.role);
        results.userDocument = true;
      } else {
        console.log("âš ï¸ User document not found, creating...");
        const newUser = await UserService.ensureUserDocument(currentUser);
        if (newUser) {
          console.log("âœ… User document created:", newUser.name, newUser.role);
          results.userDocument = true;
        }
      }
    } catch (error) {
      console.log("âŒ User document test failed:", error);
    }

    // Test 2: Basic collection reads
    try {
      const usersSnapshot = await getDocs(collection(db, "users"));
      console.log(
        "âœ… Users collection read: OK, count:",
        usersSnapshot.docs.length
      );
      results.basicRead = true;
    } catch (error) {
      console.log("âŒ Users collection read failed:", error);
    }

    // Test 3: Projects collection
    try {
      const projectsSnapshot = await getDocs(collection(db, "projects"));
      console.log(
        "âœ… Projects collection read: OK, count:",
        projectsSnapshot.docs.length
      );
      results.projectRead = true;
    } catch (error) {
      console.log("âŒ Projects collection read failed:", error);
    }

    // Test 4: Conversations collection
    try {
      const conversationsSnapshot = await getDocs(
        collection(db, "conversations")
      );
      console.log(
        "âœ… Conversations collection read: OK, count:",
        conversationsSnapshot.docs.length
      );
      results.conversationRead = true;
    } catch (error) {
      console.log("âŒ Conversations collection read failed:", error);
    }

    // Test 5: Messages collection
    try {
      const messagesSnapshot = await getDocs(collection(db, "messages"));
      console.log(
        "âœ… Messages collection read: OK, count:",
        messagesSnapshot.docs.length
      );
      results.messageRead = true;
    } catch (error) {
      console.log("âŒ Messages collection read failed:", error);
    }

    // Test 6: User service functions
    try {
      const allUsers = await UserService.getAllUsers();
      console.log("âœ… UserService.getAllUsers: OK, count:", allUsers.length);
      results.userRead = true;
    } catch (error) {
      console.log("âŒ UserService.getAllUsers failed:", error);
    }

    const successCount = Object.values(results).filter(Boolean).length;
    const totalTests = Object.keys(results).length;

    console.log("ğŸ“Š Test Results:", results);
    console.log(
      `ğŸ“ˆ Success rate: ${successCount}/${totalTests} (${Math.round(
        (successCount / totalTests) * 100
      )}%)`
    );

    return {
      success: successCount === totalTests,
      message: `Tests completed: ${successCount}/${totalTests} passed`,
      results,
    };
  } catch (error) {
    console.error("âŒ Comprehensive test failed:", error);
    return { success: false, message: "Test failed", error };
  }
};

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø´Ø±Ù
export const createProjectBySupervisor = async (
  supervisorId: string,
  projectData: {
    title: string;
    description: string;
    type: string;
    dueDate: string;
    students: string[];
  }
) => {
  try {
    const project = {
      ...projectData,
      status: "planning" as const,
      priority: "medium" as const,
      progress: 0,
      supervisorId,
      studentId: projectData.students[0] || "", // Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
      todoList: [],
      tags: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    const projectId = await ProjectService.createProject(project);

    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø·Ù„Ø§Ø¨ Ù„Ù„Ù…Ø´Ø±ÙˆØ¹
    for (const studentId of projectData.students) {
      await ProjectService.addStudentToProject(projectId, studentId);
    }

    return { success: true, projectId };
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:", error);
    return { success: false, error };
  }
};

// Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø·Ø§Ù„Ø¨
export const manageTaskByStudent = async (
  projectId: string,
  taskData: {
    id?: string;
    title: string;
    description: string;
    dueDate: string;
    priority: "low" | "medium" | "high";
    completed?: boolean;
    assignedTo: string;
  }
) => {
  try {
    const task = {
      id: taskData.id || `task-${Date.now()}`,
      title: taskData.title,
      description: taskData.description,
      completed: taskData.completed || false,
      dueDate: taskData.dueDate,
      assignedTo: taskData.assignedTo,
      priority: taskData.priority,
      createdAt: new Date().toISOString(),
      completedAt: taskData.completed ? new Date().toISOString() : undefined,
    };

    if (taskData.id) {
      // ØªØ­Ø¯ÙŠØ« Ù…Ù‡Ù…Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
      await ProjectService.updateTask(projectId, task);
    } else {
      // Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©
      await ProjectService.addTask(projectId, task);
    }

    return { success: true, task };
  } catch (error) {
    console.error("Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù‡Ù…Ø©:", error);
    return { success: false, error };
  }
};
